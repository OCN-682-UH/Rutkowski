---
title: "Week 10 Functions"
author: "Emily C Rutkowski"
format: html
---

## Introduction
1. When to write a functio
2. How to make a custom fucntion

Why functions?
  - Anytime you have a task that you want to use more than once
  - Keeps your script clean
  - Avoids mistakes with copy and paste
  - Minimizes places where you need to update your code
  
# Anytime you have a task that you want to use more than once

Lets use an exmaple where we want to rescale data in multiple columns (value-min/(max-min))

First set up your script and create a dataframe of random numbers

```{r}
library(tidyverse)
library(palmerpenguins)
library(PNWColors)
```

```{r}
df <- tibble(
  a = rnorm(10), # draws 10 random values from a normal distribution
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10))
head(df)
```

Rescale every column individually
```{r}
df<- df %>%
  mutate(a = (a-min(a, na.rm = TRUE))/(max(a, na.rm = TRUE)-min(a, na.rm = TRUE)))
```

```{r}
df<-df %>%
  mutate(a = (a-min(a, na.rm = TRUE))/(max(a, na.rm = TRUE)-min(a, na.rm = TRUE)),
         b = (b-min(b, na.rm = TRUE))/(max(a, na.rm = TRUE)-min(b, na.rm = TRUE)),
         c = (c-min(c, na.rm = TRUE))/(max(c, na.rm = TRUE)-min(c, na.rm = TRUE)),
         d = (d-min(d, na.rm = TRUE))/(max(d, na.rm = TRUE)-min(d, na.rm = TRUE)))
```

Did I make a mistake? - YES, column b has max(a, na.rm....)

We can write a function for this:
```{r}
rescale01<-function(x) {
  value<-(x-min(x, na.rm = TRUE))/(max(x, na.rm = TRUE)-min(x, na.rm = TRUE))
  return(value)
}
```

```{r}
df %>%
  mutate(a = rescale01(a),
         b = rescale01(b),
         c = rescale01(c),
         d = rescale01(d))
```

Even better! Use mutate_all to do it in even less lines of code
```{r}
df %>%
  mutate_all(rescale01) # mutate every column with the rescale01 function 
```

# 3 key steps to creating a new function

1. You need to pick a name for the function. Here Iâ€™ve used rescale01 because this function rescales a vector to lie between 0 and 1.
2. You list the inputs, or arguments, to the function inside function. Here we have just one argument. If we had more the call would look like function(x, y, z).
3. You place the code you have developed in body of the function, a { block that immediately follows function(...).
4. return tells us what values we want returned when you run the function

Let's make a function to covert degrees fahrenheit to celcius.
 - What is the calculation for F to C?
```{r}
temp_C <- (temp_F - 32) * 5/9 
```
 
 Make it a function!
 Step 1. Name the function. 
```{r}
fahrenheit_to_celcius <- function() {}
```
 
 Step 2. Put in the equation.
```{r}
fahrenheit_to_celcius <- function() {
  temp_C <- (temp_F - 32) * 5/9
}
```
 
 Step 3: Decide what the arguments are
```{r}
fahrenheit_to_celsius <- function(temp_F) {
  temp_C <- (temp_F - 32) * 5 / 9 
}
```
 
 Step 4: Decide what is being returned
```{r}
fahrenheit_to_celsius <- function(temp_F) { 
  temp_C <- (temp_F - 32) * 5 / 9 
  return(temp_C)
}
```
 
 Step 5: Test it
```{r}
fahrenheit_to_celsius(32)
```
 [1] 0
```{r}
fahrenheit_to_celsius(212)
```
 [1] 100
 
 
 Write a function that converts celcius to kelvin. (Remember Kelvin is celcius + 273.15).
 
```{r}
celcius_to_kelvin <- function(temp_C) {
  temp_K <- (temp_C +273.15)
  return(temp_K)
}
```
 
```{r}
celcius_to_kelvin(0)
```
 [1] 273.15
 
 
 **Making plots into a function**

Let's say you have a specifically formatted plot that you like and that you plan to use over and over again. By turning it into a function, you only have to code it once.

Let's use our favorite penguin dataset and make a nice plot line plot.
 
```{r}
pal <- pnw_palette("Lake", 3, type = "discrete") # my color palette 

ggplot(penguins, 
       aes(x = body_mass_g, y = bill_length_mm, color = island))+
  geom_point()+
  geom_smooth(method = "lm")+ # add a linear model
  scale_color_manual("Island", values = pal)+ # use pretty colors and another example of how to manually change the legend title for colors
  theme_bw()
```
 
 Name and set-up the function
```{r}
myplot <- function(data, x, y){
  pal<-pnw_palette("Lake",3, type = "discrete") # my color palette 
ggplot(penguins, aes(x = body_mass_g, y = bill_length_mm, color = island))+
  geom_point()+
  geom_smooth(method = "lm")+ # add a linear model
  scale_color_manual("Island", values=pal)+   # use pretty colors and change the legend title
  theme_bw()
}
```
 
 Test it
```{r}
myplot(data = penguins, x = body_mass_g, y = bill_length_mm)
```
 
 Even though body_mass_g exists within the penguin dataframe, there is still no individual parameter called body_mass_g in our environment and R is confused. There is a solution though from within the {rlang} package (a part of the tidyverse)!

{rlang} uses what is literally called a"curly-curly" {{}} to help us assign variables that are column names in dataframes.

Let's add curly-curlies to the column names

```{r}
myplot<-function(data, x, y){ 
pal<-pnw_palette("Lake",3, type = "discrete") # my color palette 
ggplot(data, aes(x = {{x}}, y = {{y}} , color = island))+
  geom_point()+
  geom_smooth(method = "lm")+ # add a linear model
  scale_color_manual("Island", values=pal)+   # use pretty colors and change the legend title
  theme_bw()
}
```
 Test again
 
```{r}
myplot(data = penguins, x = body_mass_g, y = bill_length_mm)
```
 
 Test with new variables
```{r}
myplot(data = penguins, x = body_mass_g, y = flipper_length_mm)
```
 
 **Adding defualts**
 Let's say you want to create a default for the function to always default to the penguins dataset. You can set those directly in the function.
 
```{r}
myplot<-function(data = penguins, x, y){
pal<-pnw_palette("Lake",3, type = "discrete") # my color palette 
ggplot(data, aes(x = {{x}}, y = {{y}} , color = island))+
  geom_point()+
  geom_smooth(method = "lm")+ # add a linear model
  scale_color_manual("Island", values=pal)+   # use pretty colors and change the legend title
  theme_bw()
}
```
 
 Now you can just write:
```{r}
myplot(x = body_mass_g, y = flipper_length_mm)
```
 
 **Layering the plot**
 You can also layer onto your plot using '+' just like it is a regular ggplot to change things like labels.
```{r}
myplot(x = body_mass_g, y = flipper_length_mm)+
  labs(x = "Body mass (g)",
       y = "Flipper length (mm)")
```
 
 **Add an if-else statement for more flexibility.**
 An aside on if-else statements....

Imagine you want a variable to be equal to a certain value if a condition is met. This is a typical problem that requires the if ... else ... construct. For instance:
```{r}
a <- 4
b <- 5
```
Suppose that if a > b then f should be = to 20, else f should be equal to 10. Using if/else we:
```{r}
if (a>b){ # my question
  f <- 20 # if it is true give me answer 1
} else { # else give me answer 2 
  f <- 10
}
```
When I type f I get...
```{r}
f
```

 [1] 10
 
 
 **Back to plotting**

Using if...else... we can make our function even more flexible. Let's say we want the option of adding the geom_smooth lines. We can create a variable that if set to TRUE add the geom_smooth, otherwise print without.

First add a new argument for lines and make the default TRUE for ease
```{r}
myplot<-function(data = penguins, x, y ,lines=TRUE ){ # add new argument for lines
pal<-pnw_palette("Lake",3, type = "discrete") # my color palette 
if(lines==TRUE){
ggplot(data, aes(x = {{x}}, y = {{y}} , color = island))+
  geom_point()+
  geom_smooth(method = "lm")+ # add a linear model
  scale_color_manual("Island", values=pal)+   # use pretty colors and change the legend title
  theme_bw()
}
else{
  ggplot(data, aes(x = {{x}}, y = {{y}} , color = island))+
  geom_point()+
  scale_color_manual("Island", values=pal)+   # use pretty colors and change the legend title
  theme_bw()
}
}
```

Test it
With lines
```{r}
myplot(x = body_mass_g, y = flipper_length_mm)
```

Without lines
```{r}
myplot(x = body_mass_g, y = flipper_length_mm, lines = FALSE)
```

